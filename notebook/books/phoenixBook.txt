
Part 1 - Building with Functional MVC

Topic -> Breaking down a simple Request:

  Simple Functions:
    Connection basicaly is a struct with known fields.

  Where Are all the Diagrams?
    nothing relevant

  The Layers of Phoenix:
    connection
    |> endpoint()
    |> router()
    |> pipelines()
    |> controller()
    Each request comes in through an endpoint , the first point of contact.
    Itâ€™s literally the end, or the beginning, of the Phoenix world.
    A request comes into an endpoint. From there, requests go into our router layer,
    which directs a request into the appropriate controller ,
    after passing it through a series of pipelines . As you might expect,
    a pipeline groups functions together to handle common tasks.
    You might have a pipeline for browser requests, and another for JSON requests.

  Inside Controllers
    The controller is a pipeline that looks like this:
    connection
    |> controller()
    |> common_services() -> implemented with Plug
    |> action()
    What is plug?
      A: A strategy for building web applications and a library with a few simple tools to enable
      that strategy.
    The pipeline for finding and user:
    connection
    |> find_user()
    |> view()
    |> templete()

  Building a Feature:
    all controller use ProjecWeb, :controller
    all views use ProjecWeb, :view
    the :atribute in hello/:name tell phoenix that there is a parameter :name in our route
    to catch this parameter eu have to deconstruct in the function.
    To patternMath with the parameter of the route we user
    %{"keyDefineInRoute" => variableThatWillReceiveIsValue}

  Going Deeper: The Request Pipeline
    Think of Pluf library as a specification for building applications that connect to the web.
    Each plug consumes and produces a common data structure called Plug.Conn .
    Remember, that struct represents the whole universe for a given request,
    because it has things that web applications need: the inbound request,
    the protocol, the parsed parameters, and so on.
    Plugs are functions
    Your web applications are pipelines of plugs

  Phoenix File Structure
    How does an endpoint works?
      connection
      |> Plug.Static.call()
      |> Plug.RequestId.call()
      |> Plug.Logger.call()
      |> Plug.Parsers.call()
      |> Plug.MethodOverride.call()
      |> Plug.Head.call()
      |> Plug.Session.call()
      |> HelloWeb.Router.call()

    The Router Flow

    Controllers, Views, and Templates


Chapter 3 - Controllers
  Start of a project that will hold till the end of the book.

  The Controller
    General no important stuff

  The Context
    not important

  Creating the Project
    Changed some shit

  Working with Context
    Learned how to create a struct

  Elixir Structs
    Added some new thing in the context

  Building a Controller
   View and stuff

  Using Helpers

  Showing a User

Chapter 4 - Ecto and Changesets

  Understanding Ecto
    DSL - Database Schema Language

  Using the Repository to add Data
    change the functions at account

Chapter 5 -

  In-Context Relationships
    added password db

  Managing Registration Changesets
    How to update all users update
      alias Rumbl.Repo
    for u <- Repo.preload(Repo.all(User), :credential) do
      Repo.update!(User.registration_changeset(u, %{
        credential: %{email: "#{u.username}@example.com",
          password: "temppass"}
      }))
    end


    Creating Users
      Defined the relation on form to create usrs via the UI

    The Anatomy of a Plug

    Writing an Authentication Plug
      Wrote our first plugin inside the controllers folder
      and put it on the router pipeline

    Restricting Acess
      halt() -> stops any downstream transformation

    Logging in

    Implementing login and logout
      Finished the logic, nice two chapters to take a look at it.


Chapter 6
    Using Generators

    Generating Resources


Chapter 7
  Adding Categories
    added two migrations

  Setting Up Category Seed Data

  Associatin Videos and Categories

  Diving Deeper into Ecto Queries
    No Code

  Writing queries with keyword Syntax

  Using Queries with the Pipe Syntax


Chapter 8

  Using Mix To Run Phoenix Tests

  Creatin Test Data


  The Query Api

Chapter 9 -Watching Videos

  Watching Videos

Chaper 10 - The Channel
  We call the messages events, and we put the state in a struct called socket .

