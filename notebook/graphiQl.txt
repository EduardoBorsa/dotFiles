1)  Think of a domain familiar to you and write down the types that belong to that domain.
    Draw in relationships between those types. Remember, these relationships are often
    what we think of as properties on an entity.
2)  Add a root object, and think about how you might want to connect it with your graph.
    From there, write down some GraphQL queries that would be possible to handle from that point.
    What kinds of responses might come back for these?


#a01)  In GraphiQl, what is the identifier?
       A: The internal identifier Absinthe uses to refer to this type.

       description
       Documentation we can provide for an object type that will automatically be available
       to API users using GraphQL’s built-in introspection features.
       We’ll be talking about this more in Running Our Query with GraphiQL.

       name
       The canonical GraphQL type name. While required, this will be generated for you
       automatically if you don’t provide it yourself, based on the Absinthe identifier.
       While we could customize this for our :menu_item object, the default of "MenuItem" works just fine.

       fields
       The real meat and potatoes of our object types. We’ll add some next.

       is_type_of and interfaces
       Support GraphQL’s Union and Interface abstract types, which we’ll talk more about in Understanding Abstract Types.

#a02) What are resolvers?

  While it might seem like adding resolver modules just to have them call functions from
  other modules is superfluous, it’s important to set up a solid separation of concerns early on in our project.

  In general, a resolver’s job is to mediate between the input that a user sends to
  our GraphQL API and the business logic that needs to be called to service their request.
  As your schema gets more complex, you’ll be glad you made space in the overall architecture
  of your application to keep your resolver and domain business logic separate.

#a03) Thing to remember about input Objects:

    Input objects can be nested. You can define an input object field as having an input object type.
    This nesting can be arbitrarily deep.

    Input object types, unlike normal object types, do not support circular references.
    You can’t have two input types that refer to each other, either directly or through an intermediary.

    Input object type fields can be of any type that a field argument might use.
    It’s best to just think of them as structured arguments.

#a04) How to make a field not null. (does this mean that it is obligated?)
  User the non_null macro.

#a05) How to Deal with Dependent Arguments?
  You may encounter situations where you’ve defined many arguments for a field only to discover that
  certain arguments should be non-nullable—but only in the event another argument isn’t present...or is.
  Here are two differing solutions that you can evaluate:

  Make the field arguments more complex: try grouping arguments that go together into input objects,
  like we did with menu item filtering. This lets you leave the input object nullable but
  individual input object fields as non-nullable. Sometimes it’s more important to keep a field cohesive.

  Make the field simpler: split it into multiple, simpler fields that handle narrower
  use cases and have their own documentation (via @desc). Don’t be afraid to create
  more, case-specific fields, each with a narrow focus. You can always share resolution logic and output types.

#a06) What are Absinthe Custom Typpes?

#a07) Steps to graphQl
    1) Build a Schema:
      The schema defines its domain model and how data is retreived.
      Keep in mind that your API and the underlying data representations do not need to be identical,
      or even have the same structure. One of the main values in modeling GraphQL types is that they
      can serve as an abstraction over whatever backing data store (or service) contains the associated
      data, transforming it before it’s transmitted to API users.
      Create a schema.ex in lib/project_web/

      - Making a query:
      - Add a resolver in the context schema (where the changeset resides):
      - change the router to pass thought the Absinthe.Plug

-------------GraphiQL Book ------

Chapter 1:
  For what suits GraphiQL?
    To address the modern problem of building API for rich client isde applications head on and
    other benefits.

Chapter 1.1
    What is the Schema?
      I think it is the what describes the shape of data that the API models and the input that it
      can expect from clients.
      Building a schema presents two major categories of work:
          1) Describing the types and the edges between types
          (both by defining them and adding built-in documentation, which you’ll see later).
          2) Writing the business logic that edges use to find their data.

    What is Introspection?

Chapter 1.2
   User input validations:
    GraphiQl holds the necessary logic to deal with user inputs, what does not happen in a normal
    REST API that delegates this task to the back-end, which causes the server to have unecessary
    logic to deal with.
    But how GraphiQl does this? (Deals with user input?)

    What is the QueryRootType?
      I think it is the query located inside the schema.ex.

chapter 1.3
  General description of the book

chaper 1.4 - Moving on
  Questions from this chapter:
    What is the Schema? (Kind answered)
    What is Introspection? NOT
    But how GraphiQl does this? (Deals with user input?) NOT
    What is the QueryRootType? NOT

Chapter 2 - Building a Schema
  Nothing Important

chapter 2.1 -
  Just talked about elixir and system requirements (does not show how to set up)

chapter 2.2 -
  Create a schema inside project_web/schema.ex
  remeber that the name of the object inside the elixit follow the snake_writting system
  but the GraphiQl uses camel case:
  Elixir   -> :menu_item
  GraphiQl -> MenuItem

  How to add a field to a GraphQl object?
    Just use the directive field:
      field :id, :id

chapter 2.3 -
  How to make a query?
  Whats the purpose of the resolver?
    to retreive data for a field.
    A field’s resolver is the function that runs to retrieve the data needed for a particular field.
  What are the three paramenters of a resolve function?
    A: The first is the parent value.
    The second one, I think it is for arguments, if you take a look at chapter 3.1 you'll see
    that the argument "matching" in the field is passed as the second argument with the value of
    name.

chapter 2.4 -
  Replace the router in the project
  How to add description to field?
    Use the directive @desc "Description text"


chapter 2.5 -
  Where to store the tests?
    inside the test/project_web/ create a directory for schema
    i.e: test/plate_slate_web/schema/query/menu_items_test.exs
    and create dir related to what you are testing.

  How to create tests?
    First setup a setup function which runs the Seeds.
    then setup a query. (IDK if the query title needs to be query)
    like @query """ query """
    then inside the test, setup inside the conn the queryfield:
      "query: @query"

chapter 2.6 - Moving on
  Nothing very relevant

Chapter 3.0 - Taking User Input
  Something realted to a previous mentioned topic about dealing with user input validation in the
  GraphiQl API.

Chapter 3.1 - Definig Field Arguments
  Deals with arguments, in the exaple: "matching"
  Also something of refactoring related to extract resolvers.

chapter 3.2 - Something inporant, but lost track

Chapter 3.3 - Using Enumerations Type
  Sort_order
  ! makes the variable mandatory

Chapter 3.4 - Modeling Input Objects
  adding new filters

Chpater 3.5 - Making Arguments as Non Null
  learn to use the non_null macro

Chapter 3.6 - Creating your own scalar types
  Hard but interestinf chapter
  Created the date scalar type

Chapter 3.7 - Moving on

Chapter 4 - Adding Flexibility
  About how to organize the structure of GraphiQl api

Chapter 4.1 - Organizing a Schema
  How to conect modeules that will be splited in different Modules.
  Check that when spliting a Module it users Absinthe.Schema.Notation.
    Absinthe’s import_types macro should only be used from your schema module.
    Think of your schema module like a manifest, defining the complete list of type modules needed to resolve type references.
  So, basicaly how to extract things inside the schema.ex to other files.

Chapter 4.2 - Understanfing Abstract Types

Chapter 4.3 - Using Named Fragments

Chapter 4.4 - Moving on

Chapter 5 - Making a change with mutations
  Mutations are related to REST Put, post and delete

Chapter 5.1 - Defining a Root Mutation Type
  Bla

Chapter 5.2 -
  First mutation executed

Chapter 5.3 - Handling Mutation Erros
 Extract errors from changeset for better test response
 Nice chapter on showing better messages to user

Chapter 5.4 - Mppving on

Chapter 6 - Going Live with Subscriptions
  Basicaly live shit when updating the database

Chapter 6.1 - Setting up Subscriptions
  Seting up the pre requisits to make this haapned and some questions of what is a websocket and
  other related subjects.

Chapter 6.2 - Event modeling
  First time creating a subscription

Chapter 6.3 - Sumitting Subscription
  Finished the Subscriptions part. Some macros that are nice to take a look here.

Chapter 6.4 - Testing Subscriptions
  Just testing, thats it.

Chapter 6.5 - Subscription Triggers
  How to update an order

Part2 - Publish Your Api

Chapter 7 - Resolution Middleware

Chapter 7.1 - Our First Module
  extrack error habdling in resolvers to their own module -> Part1

Chapter 7.2 - Applying the middleware
  What is the MiddleWare?
    The Macro Approach



